\chapter{Конструкторская часть}
В данном разделе будут рассмотрены схемы последовательной и параллельной реализации алгоритма поиска простых чисел, описание способов тестирования и структур данных. 
\section{Разработка алгоритмов}

%\clearpage
\img{170mm}{prime_common}{Схема однопоточного алгоритма поиска простых чисел}


\clearpage
\img{170mm}{parallel}{Cхема распараллеливания произвольной функции, способной выполняться в некоторых независимых промежутках}

\section{Модель вычислений}

Для последующего вычисления трудоемкости необходимо ввести модель вычислений:
\begin{enumerate}
    \item операции из списка (\ref{for:opers}) имеют трудоемкость 1;
        \begin{equation}
            \label{for:opers}
            +, -, /, \%, ==, !=, <, >, <=, >=, [], ++, {-}-
        \end{equation}
    \item трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
	\begin{equation}
        \label{for:if}
        f_{if} = f_{\text{условия}} +
        \begin{cases}
        f_A, & \text{если условие выполняется,}\\
        f_B, & \text{иначе.}
        \end{cases}
	\end{equation}
\item трудоемкость цикла рассчитывается, как (\ref{for:for});
    \begin{equation}
        \label{for:for}
        f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
    \end{equation}
	\item трудоемкость вызова функции равна 0.
\end{enumerate}



\section{Трудоемкость алгоритмов}

\subsection{Алгоритм поиска простых чисел (последовательная реализация)}

Во всех последующих алгоритмах не будем учитывать инициализацию матрицу, в которую записывается результат, потому что данное действие есть во всех алгоритмах и при этом не является самым трудоёмким.

Трудоёмкость алгоритма поиска простых чисел (последовательная реализация) 
Пусть $ m = \sqrt{array[i]}$ тогда трудоемкость:
\begin{itemize}
    \item внешнего цикла по $i \in [1..n]$, трудоёмкость которого: $f = n \cdot f_{body}$;
    \item цикла по $j \in [2..m]$, трудоёмкость которого: $f = m$;
\end{itemize}

Учитывая, что трудоёмкость алгоритма равна трудоёмкости внешнего цикла, можно вычислить ее, подставив циклы тела (\ref{for:standard}):
\begin{equation}
    \label{for:standard}
    f_{standard} \approx n \cdot m;
\end{equation}



\subsection{Алгоритм поиска простых чисел (параллельная реализация)}

Трудоёмкость алгоритма поиска простых чисел (параллельная реализация) 
Пусть $ m = \sqrt{array[i]}$, $left, right$ - левая и правая граница диапазона обработатываемого одним потоком, причем $n = (right - left) * count\_threads$, тогда трудоемкость (для одного потока): 
\begin{itemize}
    \item цикла по $i \in [left..right]$, трудоёмкость которого: $f = (right - left) \cdot f_{body}$;
    \item цикла по $j \in [2..m]$, трудоёмкость которого: $f = m$;
\end{itemize}

Учитывая, что алгоритм выполняется параллельно итоговая трудоекость будет равна (\ref{for:standard}):
\begin{equation}
    \label{for:standard}
    f_{parallel} \approx \frac{n \cdot m}{count\_threads};
\end{equation}


\section{Описание структур данных}
Исходя из условия задачи приходим к выводу о том, что для хранения массива найденных простых чисел наиболее удобно использовать структуру данных - массив целых чисел.

\section{Описание способов тестирования}
Данный алгоритм можно протестировать функционально. При этом можно выделить следующие классы эквивалентности: 

\begin{itemize}
    \item Входное число $n = 2$;
    \item Входное число $n > 2$;
\end{itemize}


\section{Структура ПО}
ПО будет состоять из следующих модулей:

\begin{itemize}
    \item Основной модуль
    \item Модуль включающий в себя реализацию алгоритма поиска простых чисел
    \item Модуль для работы с потоками
    \item Модуль для работы с входными и выходными данными
\end{itemize}

\section*{Вывод}


На основе теоретических данных, полученных из аналитического раздела, были построены схема алгоритма поиска простых чисел, а также схема, описывающая работу с многопоточностью.  Оценены их трудоёмкости, приведена структура ПО, описаны структуры данных.