\chapter{Аналитическая часть}
В данном разделе будут представлены теоретические сведения о рассматриваемых алгоритмах.


\section{Алгоритм полного перебора}

Алгоритмом полного перебора \cite{brute} называют метод решения задачи, при котором по очереди рассматриваются все возможные варианты. В нашем случае мы последовательно будем перебирать ключи словаря до тех пор, пока не найдём нужный. Трудоёмкость алгоритма зависит от того, присутствует ли искомый ключ в словаре, и, если присутствует - насколько он далеко от начала массива ключей.

Пусть алгоритм нашёл элемент на первом сравнении (лучший случай), тогда будет затрачено $k_0 + k_1$ операций, на втором - $k_0 + 2 \cdot k_1$, на последнем (худший случай) - $k_0 + N \cdot k_1$. Если ключа нет в массиве ключей, то мы сможем понять это, только перебрав все ключи, таким образом трудоёмкость такого случая равно трудоёмкости случая с ключом на последней позиции. Средняя трудоёмкость может быть рассчитана как математическое ожидание по формуле (\ref{for:brute}), где $\Omega$ -- множество всех возможных случаев.

\begin{equation}
    \label{for:brute}
    \begin{aligned}
        \sum\limits_{i \in \Omega} p_i \cdot f_i = & (k_0 + k_1) \cdot \frac{1}{N + 1} + (k_0 + 2 \cdot k_1) \cdot \frac{1}{N+1} +\\
        & + (k_0 + 3 \cdot k_1) \cdot \frac{1}{N + 1} + (k_0 + Nk_1)\frac{1}{N + 1} + (k_0 + N \cdot k_1) \cdot \frac{1}{N + 1} =\\
        & = k_0\frac{N+1}{N+1}+k_1+\frac{1 + 2 + \cdots + N + N}{N + 1} = \\
        & = k_0 + k_1 \cdot \left(\frac{N}{N + 1} + \frac{N}{2}\right) = k_0 + k_1 \cdot \left(1 + \frac{N}{2} - \frac{1}{N + 1}\right)
    \end{aligned}
\end{equation}




\section{Алгоритм двоичного поиска}

Бинарный поиск\cite{binary} производится в упорядоченном словаре.

При бинарном поиске искомый ключ сравнивается с ключом среднего элемента в словаре. Если они равны, то поиск успешен. В противном случае поиск осуществляется аналогично в левой или правой частях словаря.

Алгоритм может быть определен в рекурсивной и нерекурсивной формах.

Бинарный поиск также называют поиском методом деления отрезка пополам или дихотомии.

На каждом шаге осуществляется поиск середины отрезка по формуле $mid = (left + right) / 2$.

Если искомый элемент равен элементу с индексом mid, поиск завершается.
В случае если искомый элемент меньше элемента с индексом mid, на место mid перемещается правая граница рассматриваемого отрезка, в противном случае — левая граница.
На рис 1.1 приведен пример бинарного поиска.

\img{100mm}{bin}{Бинарный поиск}


\section{Алгоритм частотного анализа}

Алгоритм частотного анализа строит частотный анализ полученного словаря. Чтобы провести частотный анализ, нужно взять первый элемент каждого значения в словаре по ключу и подсчитать частотную характеристику, т.е. сколько раз этот элемент встречался в качестве первого. По полученным данным словарь разбивается на сегменты так, что все записи с одинаковым первым элементом оказываются в одном сегменте.

Сегменты упорядочиваются по значению частотной характеристики таким образом, чтобы к элементу с наибольшим значением характеристики был предоставлен самый быстрый доступ.

Затем каждый из сегментов упорядочивается по значению. Это необходимо для реализации бинарного поиска, который обеспечит эффективный поиск в сегмента при сложности $O(nlog(n))$

таким образом, сначала выбирается нужный сегмент, а затем в нем проводится бинарный поиск  нужного элемента. Средняя трудоемкость при длине алфавита $M$ может быть рассчитана по формуле \eqref{eq:freq}.

\begin{equation}
   \sum_{i \in [1, M]} (f_{select_i} + f_{search_i})
   \label{eq:freq}
\end{equation}



\section*{Вывод} 
В данной работе стоит задача реализации поиска в словаре. Входными данными будет являтся словарь записей вида: \{$car:string, description:string$\}, а также ключ для поиска в этом словаре $key$ типа $string$. Выходными данными будет являтся найденная запись для каждого из реализуемых алгоритмов. В связи с ограничениями накладываемыми на ПО, тип ключа и значения входного словаря должен быть $string$.
