\chapter{Исследовательская часть}

В данном разделе будет произведено сравнение временных характеристик каждого из реализованных алгоритмов, а также будет приведена демонстрация работы программы.



\section{Технические характеристики}

\begin{itemize}
	\item Операционная система: Windows 10. \cite{windows}
	\item Память: 16 GiB.
	\item Процессор: Intel(R) Core(TM) i7-4700HQ CPU @ 2.40GHz. \cite{intel}
\end{itemize}


\section{Временные характеристики}

Так как поиск в словаре считается короткой задачей, воспользуемся усреднением массо­вого эксперимента.
Для этого сложим результат работы алгоритма n раз (n >= 10), после чего поделим на n.
Тем самым получим достаточно точные характеристики времени.
Сравнение произведем при n = 1000.

На рис. 4.1 приведено сравнение времени выполнения
трех алгоритмов для поиска последнего значения.
По результатам эксперимента видно, что поиск полным перебором
затрачивает больше всего времени, т.к. он последовательно обходит
все элементы, в то время, как остальные два алгоритма выполняют
поиск значительно быстрее.


\img{30mm}{firstkey}{Последний ключ}

На рис. 4.2 произведено аналогичное сравнение, только в качестве искомого ключа
взят несуществующий. Аналогично поиск полным перебором
затрачивает больше всего времени по вышеописанной причине.

\img{30mm}{unexist}{Несуществующий ключ}


Однако не всегда поиск полным перебором дает худший результат.
На рис. 4.3 представлен результат поиска первого значения.
Выигрыш алгоритма поиска полным перебором обосновывается тем, что он тратит
лишь одно сравнение для того, чтобы найти первый ключ, в том время, когда
бинарный поиск затрачивает гораздо больше сравнений.
Частичный анализ работает чуть медленнее, так как ему нужно
произвести дополнительное сравнение первых букв.

\img{30mm}{firstkey2}{Первый ключ}

На рис. 4.4 представлен результат поиска произвольного ключа.
Алгоритм полного перебора работает медленнее всех.

\img{30mm}{random}{Произвольный ключ}


\section*{Вывод}

Исходя из полученных данных, можно сделать вывод, что алгоритм поиска в словаре, использующий частотный анализ, является боле эффективным, чем алгоритм полного перебора лишь в ряде случаев, в остальных же, он является менее эффективным, в связи с использованием сегментации и бинарным поиском внутри сегмента.

Отдельно отметим, что алгоритм бинарного поиска требует, в целом, меньшего числа сравнений, в связи с чем является более эффективным, чем алгоритм с частотным анализом. Однако, алгоритм бинарного поиска требует сортировки всего входного массива, что, в среднем случаи имеет сложность $O(nlog(n))$, в связи с чем алгоритм бинарного поиска становится менее эффективным, чем алгоритм частотного анализа, сортирующий данные по сегментам.
