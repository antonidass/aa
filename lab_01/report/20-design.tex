\chapter{Конструкторская часть}
В данном разделе будут рассмотрены схемы алгоритмов нахождения редакционного расстояния. Также будут описаны структуры данных и будет оценена используемая алгоритмами память.

\section{Разработка алгоритмов}
  
   


\img{190mm}{cacheLevenshtain}{Схема алгоритма поиска расстояния Левенштейна}
\img{180mm}{recLevenshtain}{Схема рекурсивного алгоритма нахождения расстояния Левенштейна}
\clearpage
\img{180mm}{cacheDamerayLevenshtain}{Схема алгоритма нахождения расстояния Дамерау-Левенштейна}
\clearpage
\img{180mm}{recDamerayLevenshtain}{Схема рекурсивного алгоритма нахождения расстояния Дамерау-Левенштейна}
\clearpage


\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры данных:
\begin{itemize}
	\item строка типа String заданного размера;
	\item длина строки - целое число типа int;
\end{itemize}


\section{Описание способов тестирования}
Данные алгоритмы нахождения редакционного расстояния можно протестировать функционально. При этом можно выделить следующие классы эквивалентности:

\begin{itemize}
    \item Две пустые строки
    \item Две одинаковые строки
    \item Нахождение расстояния при помощи операции вставки
    \item Нахождение расстояния при помощи операции замены
    \item Нахождение расстояния при помощи операции удаления
    \item Нахождения расстояния при помощи всех трех операций
\end{itemize}




\section{Характеристики по памяти}

Алгоритмы нахождения расстояний Левенштейна и Дамерау — Левенштейна не отличаются друг от друга с точки зрения использования памяти, следовательно, достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций этих алгоритмов.

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, при этом для каждого вызова рекурсии в моей реализации требуется:
\begin{itemize}
    \item перeменная типа int, в моем случае: $4 $ байта;
    \item 2 аргумента типа строка: $2 \cdot 24 = 48$ байт;
    \item адрес возврата: 8 байт;
    \item место для записи возвращаемого функцией значения: 8 байт.
\end{itemize}
Таким образом получается, что при обычной рекурсии на один вызов требуется (\ref{for:onecall}): 

\begin{equation}
M_{per call} = 4 + 48 + 8 + 8 = 68 байт
\label{for:onecall}
\end{equation}

Следовательно память, расходуемая в момент, когда стек вызовов максимален, равна (\ref{for:rec}): 

\begin{equation}
    M_{recursive} = 80 \cdot depth
\label{for:rec}
\end{equation}

где \textit{depth} - максимальная глубина стека вызовов, которая равна (\ref{for:depth}):

\begin{equation}
depth = |S_1| + |S_2|
\label{for:depth}
\end{equation}

где $S_1, S_2$ - строки.


Память, требуемая для при итеративной реализации, состоит из следующего:
\begin{itemize}
    \item 2 локальные перeменные типа int, в моем случае: $2 \cdot 4 = 8$ байт;
    \item 2 аргумента типа строка: $2 \cdot 24 = 48$ байт;
    \item адрес возврата: 8 байт;
    \item место для записи возвращаемого функцией значения: 8 байт;
    \item матрица: $M_{Matrix}$ размером $4 \cdot (n + 1) \cdot (m + 1)$.
\end{itemize}

Таким образом общая расходуемая память итеративных алгоритмов (\ref{for:iter}):

\begin{equation}
M_{iter} = M_{Matrix} + 72
\label{for:iter}
\end{equation}



\section*{Вывод}
На основе теоретических данных, полученных из аналитического раздела, были построены схемы обоих алгоритмов (Левенштейна и Дамерау-Левенштейна). Оценены их трудоемкости в лучшем и худшем случаях. Также были описаны используемые структуры данных.






